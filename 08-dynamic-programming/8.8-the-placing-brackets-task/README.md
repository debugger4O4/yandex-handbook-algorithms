### Задача «Расставить скобки».

![img.png](content%2Fimg.png)

Для выражения `(3 + 2 × 4)` существуют два способа расставить скобки: `(3 + (2 × 4)) = 11` и `((3 + 2) × 4) = 20`.

- Входные данные: Ввод содержит только строку `s` длиной `2n + 1` для некого `n` с символами `s0, s1, ..., s2n`. Каждый 
символ на чётной позиции `s` — это цифра (то есть целое число от `0` до `9`), а на нечетной позиции — одна из трёх операций
из `{+, −, ∗}`.
- Выходные данные: Максимальное значение данного арифметического выражения из всех возможных порядков арифметических операций.
- Ограничения: `0 ≤ n ≤ 14` — таким образом, строка содержит максимум `29` символов.

![img.png](content%2Fimg.png)

- `200 = (5 − ((8 + 7) × (4 − (8 + 9))))`

Каждая из пяти операций в выражении

![img_1.png](content%2Fimg_1.png)

может быть последней — внешней. Рассмотрим случай, в котором последняя операция — `«×»`, то есть умножение. В этой ситуации
нам необходимо поместить два подвыражения в скобки

![img_2.png](content%2Fimg_2.png)

таким образом, чтобы произведение значений было максимальным. Чтобы это выяснить, мы находим минимальные и максимальные 
значения данных двух подвыражений:

![img_3.png](content%2Fimg_3.png)

На основании этих значений мы заключаем, что общее значение произведения составляет `130`.

Предположим, что вводный набор данных имеет форму

![img_4.png](content%2Fimg_4.png)

где каждая `di` — это цифра, а каждая `opj ∈ {+, −, ×}` — базовая арифметическая операция. Сказанное выше предполагает, 
что мы вычисляем минимальное и максимальное значение каждого подвыражения в форме

![img_5.png](content%2Fimg_5.png)

где `0 ≤ l ≤ r ≤ n`. Пусть `minValue(l, r)` и `maxValue(l, r)` — минимальное и максимальное значение `El,r` соответственно.
Тогда

![img_6.png](content%2Fimg_6.png)

Базовый случай — это `l = r`:

![img_8.png](content%2Fimg_8.png)

Эти два рекуррентных соотношения позволяют нам вычислить оптимальные значения `El,r`, изучив все возможные варианты разделения
`El,r` на два подвыражения `El,m` и `Em+1,r`.

Тогда наше рекуррентное соотношение говорит о том, что дерево состоит из корня и двух поддеревьев. Для нахождения оптимальной
формы дерева мы анализируем все возможные корни (за это отвечает параметр `m`), а затем составляем дерево из двух оптимальных
поддеревьев.

Как обычно, сделать из рекуррентного соотношения рекурсивный алгоритм довольно просто. Рекурсивная процедура берёт индексы
`l` и `r` в качестве параметров и использует их для вычисления минимального и максимального значения подвыражения `El,r`.
Перед тем, как начать вычисления, проверяется, не сохранены ли уже эти значения в `table[l, r]`, где `table` — это ассоциативный
массив, хранящий уже вычисленные результаты. Если запись `table[l, r]` отсутствует, рекурсивная процедура вычисляет два 
значения, используя рекуррентное соотношение, сохраняет их в таблицу и выдаёт их. Конечный ответ соответствует `l = 0` и
`r = n`. Время выполнения составляет `O(n^3)`: есть `O(n^2)` возможных пар `(l, r)`, для каждой из которых рекурсивная 
процедура проверяет возможные значения для `l ≤ m < r`.

Для переведения рекурсивного алгоритма в итерационный используются двумерные таблицы `mins[0..n][0..n]` и `maxs[0..n][0..n]`,
в которых хранятся минимальные и максимальные значения всех подвыражений. Заполняя данные таблицы, нам нужно убедиться, 
что к окончанию вычислений оптимальных значений для `El,r` оптимальные значения `El,m` и `Em+1,r` для всех `m` уже вычислены.
Один из способов сделать это — перечислить все пары `(l, r)` в порядке возрастания значения `r − l`. Чтобы это сделать, 
в псевдокоде ниже используется параметр `s = r − l`.

```
MaxValue(d[0],op[0],d[1],op[1],…d[n]):
    mins, maxs = 2d-arrays of size (n+1)×(n+1)
    fill mins with +infinity, fill maxs with -infinity
    for i from 0 to n:
        mins[i][i]=d[i], maxs[i][i]←d[i]​
    for s from 1 to n:
        for l from 1 to n-s:
            r = l+s
            for m from l to r-1:
                a = mins[l][m] op[m] mins[m+1][r]
                b = mins[l][m] op[m] maxs[m+1][r]
                c = maxs[l][m] op[m] mins[m+1][r]
                d = maxs[l][m] op[m] maxs[m+1][r]
                mins[l][r] = min(mins[l][r],a,b,c,d)
                maxs[l][r] = max(maxs[l][r],a,b,c,d)
    return maxs[0][n]
```