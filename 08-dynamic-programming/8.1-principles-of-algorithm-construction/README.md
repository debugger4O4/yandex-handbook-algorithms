### Принципы построения алгоритмов.

### Основная идея.
#### Количество путей.
В нижеприведённой сети есть множество путей ведущих от `s` к `t`, — например: `s → b → e → t` и `s → a → c → d → t`. Каково
общее количество путей?<br>
![img.png](content%2Fimg.png)<br>
Так как мы начинаем с `s`, существует уникальный способ добраться до `s`. Давайте запишем:<br>
![img_1.png](content%2Fimg_1.png)<br>
Для `a` и `b` также существует просто один путь.<br>
![img_2.png](content%2Fimg_2.png)<br>
Так как существует только один путь к `a` и только один к `b`, количество путей к `c` составляет `1 + 1 = 2 (s → a → c и s → b → c)`.<br>
![img_3.png](content%2Fimg_3.png)<br>
Аналогичным образом для достижения `d` необходимо прийти либо к `a`, либо к `c`. Существует только один путь до `a` и два
пути до `c`. Так количество путей, которые ведут к `d`, составляет `1 + 2 = 3 (s → a → d, s → a → c → d и s → b → c → d)`.<br>
![img_4.png](content%2Fimg_4.png)<br>
Количество путей, заканчивающихся на `e`, равно `1`, так как к `e` можно прийти только от `b`.<br>
![img_5.png](content%2Fimg_5.png)<br>
До `c` есть два пути, до `d` — три пути, до `e` — один. Выходит, что путей до `t` существует `2 + 3 + 1 = 6`.<br>
![img_6.png](content%2Fimg_6.png)<br>

#### Динамическое программирование.
Для узла `v` - `paths(v)` будет количеством путей от стартового узла `s` к узлу `v`. Несомненно, `paths(s) = 1`. Это 
называется базовый случай. Соответствующее значение для всех других узлов можно найти с помощью рекуррентного соотношения:<br>
![img_7.png](content%2Fimg_7.png)<br>
где предшественник `v` — это узел, связанный ребром с `v`.

Многие алгоритмы динамического программирования используют одну схему:
- Вместо того, чтобы решать изначальную задачу, алгоритм решает несколько подзадач такого же типа.
- Алгоритм вычисляет решение для каждой подзадачи с помощью рекуррентного соотношения, в которое входят решения более 
мелких подзадач.
- Алгоритм сохраняет решения подзадач и таким образом избегает перевычисления.

#### Ориентированный ациклический граф: кратчайший путь.
Теперь рассмотрим взвешенный граф, в котором у каждого ребра `e` обозначена длина `length(e)`. Длина пути в таком графе 
определяется суммой длины рёбер.<br>
![img_8.png](content%2Fimg_8.png)<br>
Например, длина пути `s → b → e → t` составляет `5 + 7 + 4 = 16`. Какова минимальная длина пути от `s` до `t`?

Так как каждый путь от `s` до `t` проходит через `c`, `d` или `e` перед тем, как прийти к `t`,<br>
![img_9.png](content%2Fimg_9.png)<br>
где `length(v)` — минимальная длина пути от `s` до `v`. Расстояния до `c`, `d` и `e` можно найти с помощью похожих рекуррентных
соотношений:<br>
![img_10.png](content%2Fimg_10.png)<br>
Приведём рекуррентные соотношения для `a` и `b`:<br>
![img_11.png](content%2Fimg_11.png)<br>
Наконец, базовый случай — это `length(s) = 0`. С его помощью можно найти расстояние до всех узлов сети, включая наш узел
`t`. Для этого нужно использовать вышеприведённые рекуррентные соотношения, которые можно записать в компактной форме:<br>
![img_12.png](content%2Fimg_12.png)<br>
Для модельной ситуации удобно записывать результаты по мере того, как мы выполняем вычисления, прямо на изображении. Мы 
получаем следующие результаты.<br>
![img_13.png](content%2Fimg_13.png)<br>
В алгоритме динамического программирования для этого выполняется бэктрекинг («поиск с возвратом») решений, которые привели
к оптимальному результату. В особенности отметим один из трёх выборов, который приводит нас к значению `length(t)`.<br>
![img_14.png](content%2Fimg_14.png)![img_15.png](content%2Fimg_15.png)<br>
Исходя из этого, мы можем заключить, что последнее ребро оптимального пути — это `c → t`. Аналогично,<br>
![img_16.png](content%2Fimg_16.png)<br>
так мы приходим от `b` к `c`. Таким образом, путь от `s` до `t` длиной `12` составляет<br>
![img_17.png](content%2Fimg_17.png)<br>
У вышеприведённой сети есть удобное свойство. Оно заключается в том, что мы можем определять порядок её узлов, что 
обеспечивает следующее: каждый узел идет после всех предшествующих — то есть узлы, которые указывают на текущий узел (например,
`c`, `d` и `e` предшествуют `t`). Сети с таким свойством называются ориентированные ациклические графы. Мы увидим, что 
многие алгоритмы динамического программирования используют ориентированные ациклические графы — явно или неявно.

#### Проектирование алгоритмов динамического программирования.
- **Определить подпроблемы**. Первый и самый важный шаг — это идентифицировать подпроблемы и записать рекуррентное соотношение
(с базовым случаем). Как правило, это делается через анализ структуры оптимального решения или через оптимизацию решения, 
использующего исчерпывающий поиск.
- **Спроектировать рекурсивный алгоритм**. Сделать из рекуррентного соотношения рекурсивный алгоритм:
    - сохранить решение каждой подзадачи в таблице;
    - перед решением подзадачи проверить, нет ли уже в таблице её решения (мемоизация).
- **Спроектировать итерационный алгоритм**. Сделать из рекурсивного алгоритма итерационный алгоритм:
    - инициализировать таблицу;
    - продвигаться от мелких подзадач к большим.
- **Оценить время выполнения**. Доказать верхнее ограничение времени выполнения. Обычно произведение количества подпроблем и
времени, необходимого для решения подзадачи, предоставляет верхнее ограничение времени выполнения.
- **Обнаружить решение**. Обнаружить оптимальное решение, используя бэктрекинг рекуррентного соотношения.
- **Экономить место**. Использовать обычную структуру таблицы, чтобы проверить, можно ли сэкономить место по сравнению с
более прямым решением.