### Задача LCS.

**Наибольшая общая подпоследовательность из двух последовательностей.**<br>
![img.png](content%2Fimg.png)

Мы имеем две последовательности `A = (a1, a2, ..., an)` и `B = (b1, b2, ..., bn)`, их общая подпоследовательность длиной
`p` — это набор `p` индексов.<br>
![img_1.png](content%2Fimg_1.png)<br>
при котором<br>
![img_2.png](content%2Fimg_2.png)

Наибольшая общая подпоследовательность — общая подпоследовательность, которая обладает наибольшей длиной из всех подпоследовательностей.

Такая задача может применяться, например:
— в сопоставлении данных — утилита `diff`, операция слияния в разных системах управления версиями;
— в биоинформатике — поиск сходств в генах разных видов;
— в проверке орфографии.

- Входные данные: Первая строка: количество элементов первой подпоследовательности `n`. Вторая строка: `a1, a2, ..., an`. 
Третья строка: количество элементов второй подпоследовательности `m`. Четвёртая строка: `b1, b2, ..., bm`.
- Выходные данные: `p`.
- Ограничения: `1 ≤ n, m ≤ 100;-10^9 ≤ ai,bi ≤ 10^9` для всех `i`.<br>
![img_3.png](content%2Fimg_3.png)<br>
- Общая подпоследовательность длиной `2` — это `(2,5)`.<br>
![img_4.png](content%2Fimg_4.png)<br>
- У двух последовательностей нет общих элементов.<br>
![img_5.png](content%2Fimg_5.png)<br>
- Одна общая подпоследовательность — `(2,7)`. Ещё одна — `(2,8)`.

**Решение**.

Рассмотрим наибольшую общую подпоследовательность `C = (c1, ..., cp)`, определенную индексами `1 ≤ i < i2 < ... < ip ≤ n`
и `1 ≤ j1 < j2 < ... < jp ≤ n` (так, для каждого `1 ≤ q ≤ p,aiq = bjq = cq`):
- Последние символы `A` и `B` приводятся в `C`. В этом случае `ip = n` и `jp = m`. Тогда `(c1, ..., cp-1)` - это наибольшая
общая подпоследовательность от `(a1, ..., an-1)` и `(b1, ..., bm-1)`.
- Как минимум один из последних символов `A`  и `B` не приводится в `C`. В этом случае или `ip < n`, или `jp < m`. Тогда
`(c1, ..., cp-1)` находится полностью в `(a1, ..., an-1)` или `(b1, ..., bm-1)`.

Таким образом, мы сводим задачу с изначальными строками `A` и `B` до такой же задачи с их префиксами. Пусть `LCS(i,j)` — 
длина наибольшей общей подпоследовательности `A[1 ... i]` и `B[1 ... j]`. Выходит, что эта функция удовлетворяет следующее
рекуррентное соотношение:<br>
![img_6.png](content%2Fimg_6.png)<br>
Базовый случай для этого рекуррентного соотношения — `i = 0` или `j = 0`:<br>
![img_7.png](content%2Fimg_7.png)<br>
Полученный алгоритм приведён ниже. Его время выполнения составляет `O(nm)`.

```
LCS(A[1…n],B[1…m]):
    table = 2d array of size (n+1)×(m+1)
    table[i][0] = 0 and table[0][j] = 0 for all i,j
    for i from 1 to n:
        for j from 1 to m:
            table[i][j] = table[i−1][j]
            table[i][j] = max(table[i][j], table[i][j−1])
            if A[i]=B[j]:
                table[i][j] = max(table[i][j], table[i−1][j−1]+1)
    return table[n][m]
```

Подсказка: Наибольшая общая подпоследовательность `A = (7, 2, 9, 3, 1, 5, 9, 4)` и `B = (2, 8, 1, 3, 9, 7)` получается 
путём удаления определённых символов из `A` и `B`.

Так задача «Наибольшая общая подпоследовательность» — всего лишь задача «Редакционное расстояние», в которой запрещены 
операции «замены».

**Наибольшая общая подпоследовательность из трёх последовательностей**.<br>
![img_8.png](content%2Fimg_8.png)

Имея три последовательности: `A = (a1, a2, ..., an)`, `B = (b1, b2, ..., bm)` и `C = (c1, c2, ..., cl)` - нужно найти длину
наибольшей общей подпоследовательности для них, то есть наибольшее неотрицательное целое число `p`, при котором существуют
индексы<br>
![img_9.png](content%2Fimg_9.png)<br>
при котором<br>
![img_10.png](content%2Fimg_10.png)

- Входные данные: Первая строка: `n`. Вторая строка: `a1, a2, ..., an`. Третья строка: `m`. Четвертая строка: `b1, b2, ..., bm`.
Пятая строка: `l`. Шестая строка: `c1, c2, ..., cl`.
- Выходные данные: `p`.
- Ограничения: `1 ≤ n,m,l ≤ 100; -10^9 ≤ ai,bi,ci ≤ 10^9`.<br>
![img_11.png](content%2Fimg_11.png)<br>
- В этом случае одна общая подпоследовательность длиной `3` — это `(8, 3, 7)`. Ещё одна — `(8, 1, 7)`.

**Решение**.
Пусть `LCS(i,j,k)` — это максимальная длина общей подпоследовательности от `A[1 ... i]`, `B[1 ... j]` и `C[1 ... k]`.
Тогда<br>
![img_12.png](content%2Fimg_12.png)

Базовый случай:<br>
![img_13.png](content%2Fimg_13.png)<br>
Время выполнения соответствующего алгоритма составляет `O(nmk)`.