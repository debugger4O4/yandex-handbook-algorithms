### Задача «Расстояние редактирования».

![img.png](content%2Fimg.png)

Есть множество вариантов, как применить задачу «Расстояние редактирования». Она подойдёт для обработки текстов на естественном
языке, проверки правописания и других направлений. К примеру, биологи зачастую вычисляют редакционное расстояние, когда 
ищут мутации, вызывающие болезни.

Редакционное расстояние между двумя строками определяется как минимальное число односимвольных вставок, удалений и замен,
необходимых для преобразования одной строки в другую.

- Входные данные: Две строки, состоящие из строчных букв латинского алфавита.
- Выходные данные: Редакционное расстояние между строками.
- Ограничения: Длина обеих строк не меньше `1` и не больше `100`.<br>
![img_1.png](content%2Fimg_1.png)
- Вторую строку можно получить из первой, удалив `s`, заменив `h` на `p` и вставив `s`. Это можно компактно продемонстрировать
следующим выравниванием.
![img_2.png](content%2Fimg_2.png)
- Удалить `e`, вставить `s` после `i`, заменить `i` на `a`, заменить `g` на `c`, вставить `e` в конце.
![img_3.png](content%2Fimg_3.png)
- Совет: будьте осторожны с рекурсией.

Рассмотрим решение задачи. Выравнивание двух строк в двухрядной матрице осуществляется таким образом, чтобы первый (второй)
ряд содержал упорядоченные символы первой (второй) строки, которые перемежаются пробелами («−»).
В колонке не может быть два пробела одновременно в обеих строках.

Мы классифицируем колонки выравнивания следующим образом (первый символ из верхней строки, второй — из нижней):
— колонка с символом и пробелом
`— это удаление;`
— колонка с пробелом и символом
`— вставка;`
— колонка с двумя одинаковыми символами
`— совпадение;`
— колонка с двумя разными символами
`— это несоответствие.`
Мы ищем выравнивание, при котором минимизируется общее количество несоответствий, удалений и вставок.

Выравнивание считается оптимальным по сравнению со всеми другими возможными вариантами, если оно содержит минимум несоответствий,
удалений и вставок. Стоит обратить внимание, что может быть несколько различных оптимальных выравниваний.

В примере выше последняя колонка — это вставка. Отбросив эту колонку, мы получаем оптимальное выравнивание первой строки
и префикса второй.

Рассмотрим идею: рассчитать редакционное расстояние между каждой парой префиксов двух строк. Это более общая постановка 
задачи, но важно отметить, что, решив ее, мы найдем ответ и на интересующий нас вопрос.

Имея строки `A[1 ... n]` и `B[1 ... m]`, мы рассмотрим их префиксы `A[1 ... i]` и `B[1 ... j]` длиной `i` и `j` и обозначим
их редакционное расстояние `EditDistance(i, j)`.

Так как последняя колонка оптимального выравнивания `A[1 ... i]` и `B[1 ... j]` — это или вставка, или удаление, или 
несоответствие, или совпадение, имеем,
![img_4.png](content%2Fimg_4.png)<br>
Базовый случай для этого рекуррентного соотношения — `i = 0` и `j = 0`:<br>
![img_5.png](content%2Fimg_5.png)<br>
Это можно выразить более кратко: если `i = 0` или `j = 0`, тогда<br>
![img_6.png](content%2Fimg_6.png)

```
table = associative array
    
EditDistance(A,B,i,j):
    if table[i,j] is not yet computed:
        if i=0 or j=0:
            table[i,j] = max(i,j)
        else:
            insertion = EditDistance(A,B,i,j−1)+1
            deletion = EditDistance(A,B,i−1,j)+1
            match = EditDistance(A,B,i−1,j−1)
            mismatch = EditDistance(A,B,i−1,j−1)+1
            if A[i]=B[j]:
                table[i,j] = min(insertion,deletion,match)
            else:
                table[i,j] = min(insertion,deletion,mismatch)
    return table[i,j]
```

Время выполнения этого алгоритма составляет `O(nm)`, так как выполняется не больше `nm` рекурсивных вызовов, которые 
добавляют значения в `table`.

Рекурсивный алгоритм вычисляет `EditDistance(i, j)` для всех `0 ≤ i ≤ n` и `0 ≤ j ≤ m`. Из рекурсивного алгоритма можно 
сделать итерационный, который будет сохранять решения всех подзадач в двумерной таблице. Таблица заполняется по рядам 
проходами. Это гарантирует, что когда мы вычислим значение клетки `(i, j)`, значения клеток `(i, j−1)`, `(i−1, j)` и `(i−1, j−1)`
будут уже готовы.

```
EditDistance(A[1…n],B[1…m]):
    table = 2d array of size (n+1) * (m+1)
    table[0][j] = j for all i,j
    for i from 1 to n:
        for j from 1 to m:
            insertion = table[i][j−1]+1
            deletion = table[i−1][j]+1
            match = table[i−1][j−1]
            mismatch = table[i−1][j−1]+1
            if A[i]=B[j]:
                table[i][j] = min(insertion,deletion,match)
            else:
                table[i][j] = min(insertion,deletion,mismatch)
    return table[n][m]
```

Итоговая таблица для нашего примера изображена на рисунке ниже. Значение каждой клетки вычисляется, исходя из значений 
соседних клеток сверху, слева и слева-сверху. У каждой клетки входящие стрелки указывают на один или несколько случаев 
(вставка, удаление, несоответствие, или совпадение), которые приводят к значению этой клетки.<br>
![img_7.png](content%2Fimg_7.png)<br>

Таблица соответствует ориентированному ациклическому графу, в котором все рёбра, за исключением красных, имеют длину `1`.
А красные ребра соответствуют совпадающим символам и имеют длину `0`. Алгоритм находит на графе самый короткий путь от 
узла слева сверху до узла справа снизу.

Время выполнения алгоритма составляет `O(nm)`. Ему требуется `O(nm)` ячеек памяти для хранения двумерного массива `table`.
Расход места может быть снижен до `O(m)` (и даже до `O(min{n, m})`), если мы обратим внимание на то, что при заполнении 
текущего ряда таблицы нам нужны только клетки из текущего и предыдущего. Таким образом, вместо хранения всей таблицы 
достаточно сохранить текущий и предыдущие ряды.
