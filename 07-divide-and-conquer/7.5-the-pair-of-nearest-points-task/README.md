### Задача «Пара ближайших точек».

![img.png](content%2Fimg.png)

Задача — найти ближайшую пару точек из заданного множества.

В компьютерных графике и зрении есть множество вариантов применения этой задачи из вычислительной геометрии. Примитивный
алгоритм с квадратичным временем выполнения делает итерации, проходя через все пары точек, чтобы найти ближайшие друг к 
другу. Ваша цель — спроектировать алгоритм «разделяй и властвуй», время выполнения которого составит `O(nlogn)`.

Чтобы решить эту задачу за время `O(nlogn)`, разобьём с помощью правильно подобранной вертикальной линии данные `n` точек
пополам — множества `S1` и `S2` размера `n / 2`. Ради простоты предположим, что все координаты `x` для данных точек различные
и количество точек чётное. С помощью двух рекурсивных вызовов с параметрами `S1` и `S2` мы находим минимальные расстояния
`d1` и `d2` в этих поднаборах. Пусть `d = min{d1, d2}`.

![img_1.png](content%2Fimg_1.png)

Остаётся проверить, существуют ли такие точки
`p1 ∈ S1` и `p2 ∈ S2`, при которых расстояние между ними меньше `d`. Мы не можем себе позволить проверять все возможные 
такие пары, так как их `(n / 2) * (n / 2) = Θ(n^2)`. Для более быстрой проверки мы отбросим все точки из `S1` и `S2`, 
расстояние которых от центральной линии по `x` больше, чем `d`. Таким образом, мы сосредотачиваемся на следующей полосе:

![img_2.png](content%2Fimg_2.png)

Теперь отсортируем точки из полосы по координатам `y` и обозначим получившийся отсортированный список `P = [p0, ..., pk-1]`. 
Оказывается, что если `∣i − j∣ > 7`, то расстояние между точками `pi` и `pj` однозначно будет больше `d`.

![img_3.png](content%2Fimg_3.png)

Это приводит к следующему алгоритму. Сначала мы сортируем данные нам `n` точек по их координатам `x`, затем делим получившийся
отсортированный список на две половины `S1` и `S2` размера `n / 2`. Находим минимальные расстояния `d1` и `d2` с помощью
рекурсивных вызовов для каждого из наборов `S1` и `S2`. Пусть `d = min{d1, d2}`. Тем не менее наша работа ещё не закончена,
потому что нам также нужно найти минимальное расстояние между точками из разных наборов (то есть точкой из `S1` и точкой
из `S2`) и проверить, ниже ли это расстояние, чем `d`. Чтобы в этом убедиться, мы отфильтруем изначальный набор и оставим
только точки с дистанцией по `x` до средней линии, не превышающей `d`. После этого мы сортируем набор точек в получившейся
линии по координатам `y` и сканируем получившийся список. Вычислим расстояние от каждой точки до семи последующих точек 
списка и вычислим `d'` — минимальное расстояние, которое нам встретилось во время сканирования. Затем выведем `min{d, d'}`.

Время выполнения алгоритма соответствует рекуррентному соотношению.

![img_4.png](content%2Fimg_4.png)

`O(nlogn)` — результат сортировки точек в полосе по координате `y` при каждой итерации.

- Формат ввода: Первая строка содержит `n` точек. Каждая из следующих `n` строк определяет точку `(xi, yi)`.
- Формат вывода: Минимальное расстояние.
- Ограничения: `2 ≤ n ≤ 10^5; -10^9 ≤ xi, yi ≤ 10^9` — целые числа.
- Примеры
![img_5.png](content%2Fimg_5.png)
- Во втором примере самое маленькое расстояние — `√2`. Есть две пары точек на этом расстоянии. Ниже они выделены голубым и красным:
`(-1, -1)`  и `(-2, -2)`; `(-2, -4)`  и `(-1, 3)`.
![img_6.png](content%2Fimg_6.png)

Помните, что расстояние между точками `(x1, y1)` и `(x2, y2)` равно `√(x1 - x2)^2 + (y1 - y2)^2`. Так, хотя ввод и содержит
только целые числа, ответ не обязательно будет целым числом, и потому вам нужно обратить внимание на точность при выводе
результатов. Абсолютное значение разницы между ответом вашей программы и оптимальным значением не должно превышать `10^-3`. 
Для этого ваш ответ должен содержать не меньше четырех цифр в дробной части. Иначе даже правильно вычисленный результат 
может не пройти нашу систему проверки из-за ошибок при округлении.