### Модификация быстрой сортировки.

![img.png](content%2Fimg.png)

```
RandomizedQuickSort(c):
     if |c| <= 1: # тут и сортировать нечего
        return c
     m = random_choice(c) # выбираем случайный элемент из массива
     определяем элементы c_small меньшие m 
     определяем элементы c_large большие m
     RandomizedQuickSort(c_small) # рекурсивный вызов алгоритма
     RandomizedQuickSort(c_large)
     объединяем c_small, m и c_large в итоговый массив c_sorted
     return c_sorted
```

В этом псевдокоде подразумевается, что все элементы массива разные. Ожидаемое время выполнения алгоритма составляет `O(nlogn)`.

Алгоритм легко изменить для случая, когда в этом массиве есть повторы. Чтобы это сделать, пусть в `csmall` содержатся все
элементы со значением не более `m`, а не элементы со значением менее `m`. Тем не менее такая модификация становится медленной
даже относительно ожидаемого времени выполнения. Например, если все элементы `c` одинаковы, `c` разделяется на две части:
размер `csmall` составляет `n − 1`, а в `clarge` нет элементов. Так как это разделение требует от `RandomizedQuickSort` 
времени `a * n`, общее время выполнения составляет:
![img_1.png](content%2Fimg_1.png)
то есть `O(n^2)` вместо `O(nlogn)`.

Цель — изменить описанный выше алгоритм `RandomizedQuickSort` так, чтобы даже при последовательностях с множеством 
повторяющихся элементов ожидаемое время выполнения стало `O(nlogn)`.

- Формат ввода: Первая строка содержит целое число `n`. В следующей строке содержится последовательность из `n` целых чисел
`a0, a1, ..., an-1`.
- Формат вывода: Вывод последовательности в неубывающем порядке.
- Ограничения: `1 ≤ n ≤ 10^5;1 ≤ ai ≤ 10^9` для всех `0 ≤ i < n`.
![img_2.png](content%2Fimg_2.png)
- Совет: не используйте встроенные алгоритмы сортировки.

#### Решение.
Для ускорения `RandomizedQuickSort` мы разделим входной массив на три подмассива: элементы меньше опорного, равные ему и
элементы больше. В более простом подходе достаточно сканировать массив трижды и собрать необходимые элементы.