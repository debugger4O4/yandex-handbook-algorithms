### Двоичный поиск.

#### Разделяй и властвуй.
В этом параграфе вы узнаете об алгоритмах «разделяй и властвуй», которые помогают выполнять поиск по огромным базам данных
в миллион раз быстрее, чем алгоритмы исчерпывающего поиска. Вооружившись этой техникой, вы узнаете, что стандартный способ
умножать числа (которому вас учили в начальной школе) далеко не самый быстрый. Затем мы применим подход «разделяй и властвуй»,
чтобы спроектировать быстрые алгоритмы для сортировки. Вы узнаете, что эти алгоритмы оптимальны — то есть даже легендарный
ученый Алан Тьюринг не смог бы спроектировать алгоритм сортировки быстрее!

#### Основная идея.
Разделение задачи на подзадачи поменьше.
Рекурсивное решение каждой подзадачи.
Объединение выполненных подзадач в решение изначальной задачи.
Первые два шага — это и есть «разделяй», а последний — «властвуй». Мы продемонстрируем такой подход в нескольких примерах,
сложность которых будет возрастать.

#### Угадать число.
Игра «Угадать число» состоит в том, что оппонент загадывает целое число `1 ≤ x ≤ n`. Вы задаёте вопрос: «`x = y?`». Оппонент
отвечает либо «да», либо «`x < y`» (то есть «мое число меньше»), либо «`x > y`» (то есть «мое число больше»). Ваша задача — 
получить ответ «да», задав минимальное количество вопросов.

Пусть `n = 3`: ваша задача — угадать `1 ≤ x ≤ 3`, задав не больше двух вопросов.

Вы можете спросить: «`x = 1?`». Если ответ положительный, то вы победили.Но оппонент может ответить: «`x > 1`». Вы решаете,
что `x` равен `2` или `3`, но у вас остаётся только один вопрос. Точно так же вы можете спросить: «`x = 3?`». Тогда ваш
оппонент может ответить: «`x < 3`». В этом случае вы не сможете получить желаемый положительный ответ, задав лишь один вопрос.

Посмотрим, что будет, если вы сначала спросите: «`x = 2?`». Если оппонент отвечает, что `x = 2`, тогда игра окончена. Если
ответ — `x < 2`, то вы уже знаете, что `x = 1`. Следовательно, второй раз вы просто спрашиваете: «`x = 1?`». И теперь вы
получаете положительный ответ.Если оппонент ответит, что `x > 2`, то вы спрашиваете: «`x = 3?`». Ответ на него: «Да».

Имитация процесса угадывания. Функция `query` «знает» целое число `x`. Вызов `query(y)` сообщает нам: `x = y`, или `x < y`,
или `x > y`. Функция `guess()` находит число `x` с помощью вызова `query()`. Она вызывается с двумя параметрами: `lower`
и `upper` — так, чтобы `lower ≤ x ≤ upper`, то есть `x` находится в сегменте `[lower, upper]`. Сначала она рассчитывает 
середину `(middle)` сегмента
`[lower, upper]`, затем вызывает `query(middle)`. Если `x < middle`, тогда она продолжает работать с интервалом
`[lower, middle - 1]`. Если `x > middle`, тогда она переходит к интервалу `[middle + 1, upper]`.
```
query(y):
    x = 1618235
    if x == y:
        return 'equal'
    if x < y:
        return 'smaller'
    else:
        return 'greater'


guess(lower, upper):
    middle = (lower + upper) / 2 // целочисленное деление
    answer = query(middle)
    // можно напечатать запрос и соответствующий результат
    if answer == 'equal':
        return
    if answer == 'smaller':
        guess(lower, middle - 1)
    else:
        guess(middle + 1, upper)


guess(1, 2097151) // начальный возможный диапазон значений
```

#### Поиск по отсортированным данным.
Метод, который мы использовали для угадывания числа, известен как двоичный поиск. Пожалуй, самый важный случай применения
двоичного поиска — это поиск по отсортированным данным. Поиск — фундаментальная задача: имея последовательность и элемент
`x`, мы хотим проверить, входит ли `x` в последовательность. Например, `3` входит в последовательность `(7, 2, 5, 6, 11, 3, 2, 9)`,
а `4` — не входит. Зная о важности задачи по поиску, неудивительно, что методы для её решения есть почти во всех языках 
программирования.
<br>![img.png](content%2Fimg.png)<br>
Выполняется линейное сканирование. На это требуется `n` сравнений при последовательности длиной `n`. Если в последовательность
не входит `x`, нам необходимо просканировать все элементы: если мы будем пропускать, то мы не можем точно знать, отсутствует 
ли `x`.

Ситуация кардинально меняется, если полученные данные отсортированы в порядке возрастания.
Это значительное ускорение: линейный поиск по отсортированному массиву с миллиардом элементов потребует миллиарда сравнений,
двоичному же поиску будет достаточно не больше `log2 10^0 < 30`.
<br>![img_1.png](content%2Fimg_1.png)<br>
- Формат ввода: Отсортированный массив `K` неповторяющихся целых чисел и целое число `q`. Первые две строки ввода содержат
целое число `n` и последовательность `k0 < k1 < ... < kn-1` из `n` неповторяющихся положительных целых чисел в 
возрастающем порядке. Следующая строка содержит целое число `q`.
- Формат вывода: Позиция элемента в `K` равного `q` или `−1` при отсутствии такого элемента.
- Ограничения: `1 ≤ n ≤ 3 * 10^4;1 ≤ ki ≤ 10^9` для всех `0 ≤ i ≤ n;1 ≤ q ≤ 10^9`.
- Примеры
<br>![img_2.png](content%2Fimg_2.png)<br>

Можно решить эту задачу примитивным способом — просканировать массив `K` (время выполнения составит `O(n)`). Время решения
этой задачи для алгоритма `BinarySearch` — `O(logn)`. Он инициализируется при присвоении `minIndex` значения `0` и `maxIndex`
значения `n − 1`. Сначала алгоритм присваивает `midIndex` значение `(minIndex + maxIndex) / 2`, а затем проверяет, больше
`q`, чем `K[midIndex]`, или нет. Если `q` больше, чем это значение, то `BinarySearch` проводит итерацию на подмассиве
`K` от `minIndex` до `midIndex − 1`. В ином случае он проводит итерацию на подмассиве `K` от `midIndex + 1` до `maxIndex`.
В конечном счёте алгоримт определит, находится `q` в `K` или нет.
```
BinarySearch(K[0..n−1], q)
    minIndex = 0
    maxIndex = n−1
    while maxIndex >= minIndex:
        midIndex = (minIndex+maxIndex) / 2 // целочисленное деление
        if K[midIndex] = q:
            return midIndex
        else K[midIndex] < q:
            minIndex = midIndex + 1
        else:
            maxIndex = midIndex - 1
    return -1
```
Например, если `q = 9` и `K=[1, 3, 7, 8, 9, 12, 15]`, `BinarySearch` сначала задаст следующее: `minIndex = 0`, `maxIndex = 6`
и `midIndex = 3`. Так как `q` больше, чем `K[midIndex] = 8`, мы рассматриваем подмассив, элементы которого больше `K[midIndex]`,
установив `minIndex = 4`, и таким образом `midIndex` перевычисляется как `(4 + 6) / 2 = 5`. В этот раз `q` меньше, чем
`K[midIndex] = 12`, поэтому мы рассматриваем подмассив, элементы которого ниже этого значения. Этот подмассив состоит из
одного элемента — `q`.

Время выполнения `BinarySearch` составляет `O(logn)`, так как алгоритм снижает длину подмассива минимум в два раза при 
каждой итерации цикла `while`. Обратите внимание: наша система оценки не может знать, использовали вы быстрый алгоритм с
трудоёмкостью `O(logn)` для поиска в отсортированном массиве или примитивный алгоритм с трудоёмкостью `O(n)`. Дело в том,
что любой программе требуется линейное время для чтения данных ввода. По этой причине мы предлагаем вам решить следующую
более общую задачу.

#### Множественный поиск ключей в отсортированной последовательности.
- Вывод: При каждом `qi` необходимо проверить, входит ли `qi` в `K`.
- Формат ввода: Отсортированный массив `K` неповторяющихся целых чисел и массив целых чисел `Q = [q0, ... , qn-1]`. Первые
две строки ввода содержат целое число `n` и последовательность `k0 < k1 < ... < kn-1` из `n` неповторяющихся положительных
целых чисел в возрастающем порядке. Следующие две строки содержат целое число `m` и `m` положительных целых чисел
`q0, q1, ..., qm-1`.
- Формат вывода: Для всех `i` от `0` до `m − 1` выведите индекс `0 ≤ j ≤ n−1`, чтобы `kj = qi` или `-1` при отсутствии 
такого индекса.
- Ограничения: `1 ≤ n ≤ 3 * 10^4;1 ≤ m ≤ 10^5;1 ≤ ki ≤ 10^9` для всех `0 ≤ i ≤ n;1 ≤ qj ≤ 10^9` для всех `o ≤ j < m`.
- Примеры
<br>![img_3.png](content%2Fimg_3.png)<br>
- Совет: не используйте встроенный двоичный поиск.

#### Двоичный поиск с дублированием.
«Искусство программирования» Дональд Кнут: «Хотя основная идея двоичного поиска относительно проста, детали могут быть на
удивление сложными». Он подразумевает изменённую версию классической задачи двоичного поиска:

Когда Кнут попросил профессиональных программистов из таких ведущих компаний, как IBM, реализовать эффективный алгоритм 
двоичного поиска с дублированием, в 90% из них были баги — год за годом. И правда, хотя первый алгоритм двоичного поиска
был опубликован в 1946 году, первый алгоритм для поиска с дублированием, в котором не было багов, впервые опубликовали 
только в 1962 году.

По аналогии с предыдущей задачей здесь мы предлагаем найти `m` целых чисел, а не одно.
- Формат ввода: Первые две строки ввода содержат целое число `n` и последовательность `k0 < k1 < ... < kn-1` из `n` 
положительных целых чисел в неубывающем порядке. Следующие две строки содержат целое число `m` и `m` положительных целых
чисел `q0, q1, ..., qm-1`.
- Формат вывода: Для всех `i` от `0` до `m − 1` вывод индекса `0 ≤ j ≤ n−1` первого встречающегося `qi` (то есть `kj = qi`)
или `-1` — если такого индекса нет.
- Ограничения: `1 ≤ n ≤ 3 * 10^4;1 ≤ m ≤ 10^5;1 ≤ ki ≤ 10^9` для всех `0 ≤ i ≤ n;1 ≤ qj ≤ 10^9` для всех `o ≤ j < m`.
- Примеры
<br>![img_4.png](content%2Fimg_4.png)<br>
- Совет: не используйте встроенный двоичный поиск.

#### Решение
У вас есть ключ `q` и вам необходимо найти первое, самое раннее место, где этот ключ встречается в массиве `K`. Например,
если `K = {3, 6, 6, 7, 7, 7, 7, 9}` и ключ `q` — это `7`, тогда первое место, где он встречается, — это индекс `3`.Разумеется,
вы можете найти одно из мест, просто начав двоичный поиск. Чтобы найти первое место, где ключ встречается, вы можете 
последовательно проверять элемент перед позицией того, который был найден, — что и демонстрируется в выделенных голубым 
строках приведенного ниже псевдокода.
```
NaiveBinarySearchWithDuplicates(K[0..n−1], q)
    minIndex = 0
    maxIndex = n−1
    while maxIndex >= minIndex:
        midIndex = (minIndex + maxIndex) / 2
        if K[midIndex] = q:
            top = midIndex
            while top > 0 and K[top − 1] = K[top]:
                top = top - 1
            return top
        if K[midIndex] < q:
            minIndex = midIndex + 1
        else:
            maxIndex = midIndex − 1
    return -1
```
Этот алгоритм может существенно замедлиться при массиве с большим количеством повторов. Например, если повторяющийся 
элемент занимает половину массива, то `NaiveBinarySearchWithDuplicates` потребует линейное время `O(n)` вместо логарифмического
времени `O(logn)`. Эта проблема устранена в псевдокоде ниже.
```
NaiveBinarySearchWithDuplicates(K[0..n−1], q)
    minIndex = 0
    maxIndex = n−1
    result = -1
    while maxIndex >= minIndex:
        midIndex = (minIndex + maxIndex) / 2
        if K[midIndex] = q:
            maxIndex = midIndex - 1
            result = midIndex
        else if K[midIndex] < q:
            minIndex = midIndex + 1
        else:
            maxIndex = midIndex − 1
    return result
```