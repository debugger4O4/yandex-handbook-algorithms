### Задача «Сбор подписей».
<br>![img.png](content%2Fimg.png)<br>
На этот раз ваша задача — собрать подписи со всех жильцов дома. Вам известно время, в которое каждый из них будет у себя.
Естественно, вам хочется собрать все подписи, заходя в дом минимальное количество раз. Для простоты давайте предположим,
что вы, зайдя в дом, собираете подписи сразу со всех жильцов, которые на месте.

В дальнейшем под сегментом будем понимать интервал времени нахождения жильца в доме. Количество жильцов будет соответствовать
количеству сегментов.

- Входные данные: Количество сегментов в первой строке — `n`. Каждая из следующих `n` строк содержит два целых числа
`li` и `ri` (разделены пробелом), которые указывают на координаты границ `i`-го сегмента.
- Выходные данные: Минимальное количество `k` точек на первой строке и координаты `k` точек целыми числами (разделены пробелом)
на второй строке. Выводить точки можно в любом порядке. При наличии нескольких наборов точек, можно вывести любой из них.
- Ограничения: `1 ≤ n ≤ 100;0 ≤ li ≤ ri ≤ 10^9` для всех `i`.
<br>![img_1.png](content%2Fimg_1.png)<br>
- Все три сегмента `[1,3]`, `[2,5]`, `[3,6]` содержат точку с координатами `3`.

<br>![img_2.png](content%2Fimg_2.png)<br>
Второй и третий сегменты содержат точку с координатами `3`, в то время как первый и четвертый содержат точку с координатами
`6`. Одной точкой покрыть все сегменты нельзя, так как `[1,3]` и `[5,6]` не пересекаются. В этом случае есть еще одно верное
решение — точки 2 и 5.

#### Решение.
Решение заключается в выявлении сегмента с наименьшим значением правой границы.

Самое маленькое значение границы сегмента: `rm = min{r1, ..., rn}`. Мы утверждаем, что существует оптимальное решение, 
включающее в себя точку `rm`. Чтобы доказать это, возьмём оптимальное решение `S`. Оно должно покрывать сегмент `[lm, rm]`,
поэтому `S` содержит точку `x`
x, что приводит к `lm ≤ x ≤ rm`. Если `x = rm`, то наша работа закончена. Иначе `x < rm`. В этом случае мы можем заменить
`x` на `rm` в `S`.
<br>![img_3.png](content%2Fimg_3.png)<bt>

Понятно, что это не меняет размер решения `S`. Чтобы доказать, что `S` всё ещё является решением, подойдём от противного
и предположим, что некий сегмент `[li, ri]` покрывается `x`, но не покрывается `rm`. Это означает `li ≤ x ≤ ri < rm` и 
противоречит тому, что `rm` — самое маленькое значение правой границы.

Таким образом, мы приходим к следующему алгоритму:
- добавить в решение минимальное значение правой границы `rm`,
- отбросить все сегменты, покрытые `rm`,
- повторить.
```
SegmentsCover(segments):
    points←empty set
    while segments is not empty:
        r_m = minimum right endpoint of a segment from segments
        add r_m points
        remove segments covered by r_m from the set segments
    return points
```
<br>![img_4.png](content%2Fimg_4.png)<br>